<?xml version="1.0" encoding="UTF-8"?>
<implementation_details>
    <description>
        Specific implementation details, code examples, and technical specifications
        for the SVG to Compose ImageVector converter project.
    </description>
    
    <project_structure>
        <uv_project>
            <pyproject_toml>
                [project]
                name = "svg-to-compose-vector"
                version = "0.1.0"
                description = "Convert SVG files to Compose ImageVector Kotlin code"
                dependencies = [
                    "click>=8.0.0",
                    "jinja2>=3.0.0",
                ]
                
                [project.scripts]
                svg2compose = "src.cli:main"
                
                [build-system]
                requires = ["hatchling"]
                build-backend = "hatchling.build"
            </pyproject_toml>
        </uv_project>
    </project_structure>
    
    <ir_implementation_examples>
        <file name="ir/color.py">
            <code>
                from dataclasses import dataclass
                from typing import Optional
                import re
                
                @dataclass(frozen=True)
                class IrColor:
                    argb: int
                    
                    @classmethod
                    def from_hex(cls, hex_string: str) -> 'IrColor':
                        """Parse hex color: #RGB, #RRGGBB, #RRGGBBAA"""
                        hex_string = hex_string.lstrip('#')
                        if len(hex_string) == 3:
                            # RGB -> RRGGBB
                            hex_string = ''.join(c*2 for c in hex_string)
                        if len(hex_string) == 6:
                            # RRGGBB -> FFRRGGBB (opaque)
                            hex_string = 'FF' + hex_string
                        return cls(int(hex_string, 16))
                    
                    @classmethod
                    def from_rgb(cls, r: int, g: int, b: int, a: int = 255) -> 'IrColor':
                        """Create from RGBA components (0-255)"""
                        return cls((a << 24) | (r << 16) | (g << 8) | b)
                    
                    def to_compose_color(self) -> str:
                        """Generate Compose Color(...) code"""
                        if self.argb in COMPOSE_NAMED_COLORS:
                            return f"Color.{COMPOSE_NAMED_COLORS[self.argb]}"
                        return f"Color(0x{self.argb:08X})"
                    
                    @property
                    def alpha(self) -> int:
                        return (self.argb >> 24) & 0xFF
                    
                    @property
                    def red(self) -> int:
                        return (self.argb >> 16) & 0xFF
                    
                    @property
                    def green(self) -> int:
                        return (self.argb >> 8) & 0xFF
                    
                    @property
                    def blue(self) -> int:
                        return self.argb & 0xFF
                
                # Compose named colors mapping
                COMPOSE_NAMED_COLORS = {
                    0xFF000000: "Black",
                    0xFFFFFFFF: "White",
                    0xFFFF0000: "Red",
                    0xFF00FF00: "Green",
                    0xFF0000FF: "Blue",
                    # ... more named colors
                }
            </code>
        </file>
        
        <file name="ir/path_node.py">
            <code>
                from abc import ABC, abstractmethod
                from dataclasses import dataclass
                from typing import List
                
                @dataclass(frozen=True)
                class IrPathNode(ABC):
                    """Base class for all path nodes"""
                    
                    @abstractmethod
                    def to_compose_dsl(self) -> str:
                        """Generate Compose path DSL code"""
                        pass
                
                @dataclass(frozen=True)
                class IrClose(IrPathNode):
                    def to_compose_dsl(self) -> str:
                        return "close()"
                
                @dataclass(frozen=True)
                class IrMoveTo(IrPathNode):
                    x: float
                    y: float
                    
                    def to_compose_dsl(self) -> str:
                        return f"moveTo({self.x:.3f}f, {self.y:.3f}f)"
                
                @dataclass(frozen=True)
                class IrLineTo(IrPathNode):
                    x: float
                    y: float
                    
                    def to_compose_dsl(self) -> str:
                        return f"lineTo({self.x:.3f}f, {self.y:.3f}f)"
                
                @dataclass(frozen=True)
                class IrCurveTo(IrPathNode):
                    x1: float
                    y1: float
                    x2: float
                    y2: float
                    x3: float
                    y3: float
                    
                    def to_compose_dsl(self) -> str:
                        return (f"curveTo({self.x1:.3f}f, {self.y1:.3f}f, "
                               f"{self.x2:.3f}f, {self.y2:.3f}f, "
                               f"{self.x3:.3f}f, {self.y3:.3f}f)")
                
                # ... more PathNode implementations
            </code>
        </file>
        
        <file name="ir/vector_node.py">
            <code>
                from abc import ABC, abstractmethod
                from dataclasses import dataclass, field
                from typing import List, Optional
                from .path_node import IrPathNode
                from .color import IrColor
                from .gradient import IrFill, IrStroke
                
                @dataclass(frozen=True)
                class IrVectorNode(ABC):
                    """Base class for vector nodes"""
                    name: str = ""
                
                @dataclass(frozen=True)
                class IrVectorPath(IrVectorNode):
                    paths: List[IrPathNode]
                    fill: Optional[IrFill] = None
                    fill_alpha: float = 1.0
                    stroke: Optional[IrStroke] = None
                    stroke_alpha: float = 1.0
                    stroke_line_width: float = 0.0
                    stroke_line_cap: str = "Butt"  # StrokeCap enum
                    stroke_line_join: str = "Miter"  # StrokeJoin enum
                    stroke_line_miter: float = 4.0
                    path_fill_type: str = "NonZero"  # PathFillType enum
                
                @dataclass(frozen=True)
                class IrVectorGroup(IrVectorNode):
                    nodes: List[IrVectorNode] = field(default_factory=list)
                    rotation: float = 0.0
                    pivot_x: float = 0.0
                    pivot_y: float = 0.0
                    scale_x: float = 1.0
                    scale_y: float = 1.0
                    translation_x: float = 0.0
                    translation_y: float = 0.0
                    clip_path_data: List[IrPathNode] = field(default_factory=list)
            </code>
        </file>
    </ir_implementation_examples>
    
    <parser_implementation_examples>
        <file name="parser/path_parser.py">
            <code>
                import re
                from typing import List, Iterator, Tuple
                from ..ir.path_node import *
                
                class PathParser:
                    # Regex for path tokenization
                    PATH_REGEX = re.compile(r'([MmLlHhVvCcSsQqTtAaZz])|([+-]?[0-9]*\.?[0-9]+(?:[eE][+-]?[0-9]+)?)')
                    
                    def parse_path_data(self, path_string: str) -> List[IrPathNode]:
                        """Parse SVG path data string into PathNode list"""
                        tokens = self._tokenize(path_string)
                        nodes = []
                        
                        current_command = None
                        command_args = []
                        
                        for token in tokens:
                            if self._is_command(token):
                                # Process previous command if exists
                                if current_command:
                                    nodes.extend(self._create_nodes(current_command, command_args))
                                
                                current_command = token
                                command_args = []
                            else:
                                # Numeric argument
                                command_args.append(float(token))
                        
                        # Process final command
                        if current_command:
                            nodes.extend(self._create_nodes(current_command, command_args))
                        
                        return nodes
                    
                    def _tokenize(self, path_string: str) -> List[str]:
                        """Tokenize path string into commands and coordinates"""
                        matches = self.PATH_REGEX.findall(path_string)
                        tokens = []
                        for command, coord in matches:
                            if command:
                                tokens.append(command)
                            elif coord:
                                tokens.append(coord)
                        return tokens
                    
                    def _is_command(self, token: str) -> bool:
                        """Check if token is a path command"""
                        return token in 'MmLlHhVvCcSsQqTtAaZz'
                    
                    def _create_nodes(self, command: str, args: List[float]) -> List[IrPathNode]:
                        """Create PathNode instances from command and arguments"""
                        nodes = []
                        
                        if command in 'Zz':
                            nodes.append(IrClose())
                        elif command == 'M':
                            # MoveTo with implicit LineTo for subsequent coordinates
                            if len(args) >= 2:
                                nodes.append(IrMoveTo(args[0], args[1]))
                                for i in range(2, len(args), 2):
                                    if i + 1 < len(args):
                                        nodes.append(IrLineTo(args[i], args[i + 1]))
                        elif command == 'm':
                            # Relative MoveTo
                            if len(args) >= 2:
                                nodes.append(IrRelativeMoveTo(args[0], args[1]))
                                for i in range(2, len(args), 2):
                                    if i + 1 < len(args):
                                        nodes.append(IrRelativeLineTo(args[i], args[i + 1]))
                        elif command == 'L':
                            for i in range(0, len(args), 2):
                                if i + 1 < len(args):
                                    nodes.append(IrLineTo(args[i], args[i + 1]))
                        elif command == 'C':
                            for i in range(0, len(args), 6):
                                if i + 5 < len(args):
                                    nodes.append(IrCurveTo(
                                        args[i], args[i + 1],
                                        args[i + 2], args[i + 3],
                                        args[i + 4], args[i + 5]
                                    ))
                        # ... handle other commands
                        
                        return nodes
            </code>
        </file>
        
        <file name="parser/color_parser.py">
            <code>
                import re
                from typing import Optional
                from ..ir.color import IrColor
                
                class ColorParser:
                    # Color parsing regexes
                    HEX_REGEX = re.compile(r'#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6}|[0-9A-Fa-f]{8})')
                    RGB_REGEX = re.compile(r'rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)')
                    RGBA_REGEX = re.compile(r'rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([0-9.]+)\s*\)')
                    
                    # Named colors mapping
                    NAMED_COLORS = {
                        'black': 0xFF000000,
                        'white': 0xFFFFFFFF,
                        'red': 0xFFFF0000,
                        'green': 0xFF00FF00,
                        'blue': 0xFF0000FF,
                        'transparent': 0x00000000,
                        # ... more named colors
                    }
                    
                    def parse_color(self, color_string: str) -> Optional[IrColor]:
                        """Parse color string to IrColor"""
                        if not color_string or color_string == 'none':
                            return None
                        
                        color_string = color_string.strip().lower()
                        
                        # Try hex format
                        hex_match = self.HEX_REGEX.match(color_string)
                        if hex_match:
                            return IrColor.from_hex(color_string)
                        
                        # Try rgb format
                        rgb_match = self.RGB_REGEX.match(color_string)
                        if rgb_match:
                            r, g, b = map(int, rgb_match.groups())
                            return IrColor.from_rgb(r, g, b)
                        
                        # Try rgba format
                        rgba_match = self.RGBA_REGEX.match(color_string)
                        if rgba_match:
                            r, g, b, a = rgba_match.groups()
                            alpha = int(float(a) * 255)
                            return IrColor.from_rgb(int(r), int(g), int(b), alpha)
                        
                        # Try named color
                        if color_string in self.NAMED_COLORS:
                            return IrColor(self.NAMED_COLORS[color_string])
                        
                        # Unknown color format
                        raise ValueError(f"Unknown color format: {color_string}")
            </code>
        </file>
    </parser_implementation_examples>
    
    <generator_implementation_examples>
        <file name="generator/image_vector_generator.py">
            <code>
                from typing import List, Set
                from ..ir.image_vector import IrImageVector
                from ..ir.vector_node import IrVectorPath, IrVectorGroup
                from .kotlin_builder import KotlinCodeBuilder
                
                class ImageVectorGenerator:
                    def __init__(self):
                        self.imports: Set[str] = set()
                    
                    def generate(self, ir: IrImageVector) -> tuple[str, Set[str]]:
                        """Generate ImageVector.Builder code and required imports"""
                        builder = KotlinCodeBuilder()
                        self.imports.clear()
                        
                        # Start ImageVector.Builder
                        builder.add_line("ImageVector.Builder(")
                        builder.indent()
                        
                        # Add non-default parameters only
                        if ir.name:
                            builder.add_line(f'name = "{ir.name}",')
                        
                        builder.add_line(f"defaultWidth = {ir.default_width:.1f}.dp,")
                        builder.add_line(f"defaultHeight = {ir.default_height:.1f}.dp,")
                        builder.add_line(f"viewportWidth = {ir.viewport_width:.1f}f,")
                        builder.add_line(f"viewportHeight = {ir.viewport_height:.1f}f")
                        
                        if ir.auto_mirror:
                            builder.add_line("autoMirror = true")
                        
                        builder.dedent()
                        builder.add_line(").apply {")
                        builder.indent()
                        
                        # Generate nodes
                        for node in ir.nodes:
                            self._generate_node(builder, node)
                        
                        builder.dedent()
                        builder.add_line("}.build()")
                        
                        self.imports.update([
                            "androidx.compose.ui.graphics.vector.ImageVector",
                            "androidx.compose.ui.graphics.vector.path",
                            "androidx.compose.ui.unit.dp"
                        ])
                        
                        return builder.build(), self.imports
                    
                    def _generate_node(self, builder: KotlinCodeBuilder, node):
                        """Generate code for a vector node"""
                        if isinstance(node, IrVectorPath):
                            self._generate_path(builder, node)
                        elif isinstance(node, IrVectorGroup):
                            self._generate_group(builder, node)
                    
                    def _generate_path(self, builder: KotlinCodeBuilder, path: IrVectorPath):
                        """Generate path(...) { } block"""
                        params = []
                        
                        if path.fill:
                            fill_code = self._generate_fill(path.fill)
                            params.append(f"fill = {fill_code}")
                        
                        if path.fill_alpha != 1.0:
                            params.append(f"fillAlpha = {path.fill_alpha:.3f}f")
                        
                        if path.stroke:
                            stroke_code = self._generate_stroke(path.stroke)
                            params.append(f"stroke = {stroke_code}")
                        
                        # Add other non-default parameters...
                        
                        if params:
                            builder.add_line("path(")
                            builder.indent()
                            for i, param in enumerate(params):
                                suffix = "," if i < len(params) - 1 else ""
                                builder.add_line(f"{param}{suffix}")
                            builder.dedent()
                            builder.add_line(") {")
                        else:
                            builder.add_line("path {")
                        
                        builder.indent()
                        
                        # Generate path data DSL
                        for path_node in path.paths:
                            builder.add_line(path_node.to_compose_dsl())
                        
                        builder.dedent()
                        builder.add_line("}")
                    
                    def _generate_fill(self, fill) -> str:
                        """Generate fill brush code"""
                        if hasattr(fill, 'color'):
                            # Solid color fill
                            self.imports.add("androidx.compose.ui.graphics.SolidColor")
                            return f"SolidColor({fill.color.to_compose_color()})"
                        elif hasattr(fill, 'color_stops'):
                            # Gradient fill
                            if hasattr(fill, 'start_x'):
                                # Linear gradient
                                return self._generate_linear_gradient(fill)
                            else:
                                # Radial gradient
                                return self._generate_radial_gradient(fill)
                        
                        return "null"
            </code>
        </file>
        
        <file name="parser/transform_parser.py">
            <description>Complete SVG transform attribute parsing with mathematical matrix operations</description>
            <code>
                import re
                import math
                from typing import List, Dict, Any
                from dataclasses import dataclass
                
                @dataclass
                class TransformMatrix:
                    """2D transformation matrix representation"""
                    a: float = 1.0  # Scale X
                    b: float = 0.0  # Skew Y
                    c: float = 0.0  # Skew X
                    d: float = 1.0  # Scale Y
                    e: float = 0.0  # Translate X
                    f: float = 0.0  # Translate Y
                
                @dataclass
                class DecomposedTransform:
                    """Decomposed transform for Compose parameters"""
                    translation_x: float = 0.0
                    translation_y: float = 0.0
                    scale_x: float = 1.0
                    scale_y: float = 1.0
                    rotation: float = 0.0
                    pivot_x: float = 0.0
                    pivot_y: float = 0.0
                
                class TransformParser:
                    """Parse SVG transform attributes and convert to Compose parameters"""
                    
                    def __init__(self):
                        self.transform_regex = re.compile(
                            r'(translate|scale|rotate|skewX|skewY|matrix)\s*\(\s*([^)]*)\s*\)',
                            re.IGNORECASE
                        )
                    
                    def parse_transform(self, transform_string: str) -> DecomposedTransform:
                        """Parse SVG transform string and return decomposed transform"""
                        if not transform_string:
                            return DecomposedTransform()
                        
                        # Parse all transform functions
                        functions = []
                        for match in self.transform_regex.finditer(transform_string):
                            func_name = match.group(1).lower()
                            params_str = match.group(2).strip()
                            params = self._parse_parameters(params_str)
                            functions.append((func_name, params))
                        
                        if not functions:
                            return DecomposedTransform()
                        
                        # Build composite matrix by applying transforms in order
                        matrix = TransformMatrix()
                        for func_name, params in functions:
                            func_matrix = self._create_function_matrix(func_name, params)
                            matrix = self._multiply_matrices(matrix, func_matrix)
                        
                        # Decompose final matrix into Compose-compatible parameters
                        return self._decompose_matrix(matrix)
                    
                    def _create_function_matrix(self, func_name: str, params: List[float]) -> TransformMatrix:
                        """Create transformation matrix for specific function"""
                        if func_name == "translate":
                            tx = params[0] if len(params) > 0 else 0.0
                            ty = params[1] if len(params) > 1 else 0.0
                            return TransformMatrix(e=tx, f=ty)
                        
                        elif func_name == "scale":
                            sx = params[0] if len(params) > 0 else 1.0
                            sy = params[1] if len(params) > 1 else sx
                            return TransformMatrix(a=sx, d=sy)
                        
                        elif func_name == "rotate":
                            angle = params[0] if len(params) > 0 else 0.0
                            cx = params[1] if len(params) > 1 else 0.0
                            cy = params[2] if len(params) > 2 else 0.0
                            
                            angle_rad = math.radians(angle)
                            cos_a = math.cos(angle_rad)
                            sin_a = math.sin(angle_rad)
                            
                            if cx == 0.0 and cy == 0.0:
                                return TransformMatrix(a=cos_a, b=sin_a, c=-sin_a, d=cos_a)
                            else:
                                # Rotation around point (cx, cy)
                                return TransformMatrix(
                                    a=cos_a, b=sin_a, c=-sin_a, d=cos_a,
                                    e=cx * (1 - cos_a) + cy * sin_a,
                                    f=cy * (1 - cos_a) - cx * sin_a
                                )
                        
                        elif func_name == "matrix":
                            if len(params) >= 6:
                                return TransformMatrix(
                                    a=params[0], b=params[1], c=params[2],
                                    d=params[3], e=params[4], f=params[5]
                                )
                        
                        return TransformMatrix()  # Identity
                    
                    def _decompose_matrix(self, matrix: TransformMatrix) -> DecomposedTransform:
                        """Decompose transformation matrix into Compose parameters"""
                        # Extract translation
                        translation_x = matrix.e
                        translation_y = matrix.f
                        
                        # Calculate scale factors
                        scale_x = math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b)
                        scale_y = math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d)
                        
                        # Handle negative scales (flips)
                        if matrix.a < 0 or (matrix.a == 0 and matrix.b < 0):
                            scale_x = -scale_x
                        if matrix.d < 0 or (matrix.d == 0 and matrix.c > 0):
                            scale_y = -scale_y
                        
                        # Calculate rotation
                        rotation = 0.0
                        if scale_x != 0:
                            rotation = math.degrees(math.atan2(matrix.b, matrix.a))
                        rotation = rotation % 360
                        
                        # Round to avoid precision issues
                        return DecomposedTransform(
                            translation_x=round(translation_x, 5),
                            translation_y=round(translation_y, 5),
                            scale_x=round(scale_x, 5),
                            scale_y=round(scale_y, 5),
                            rotation=round(rotation, 5),
                            pivot_x=0.0,
                            pivot_y=0.0
                        )
            </code>
        </file>
        
        <file name="generator/kotlin_builder.py">
            <code>
                from typing import List, Set
                
                class KotlinCodeBuilder:
                    def __init__(self, indent_size: int = 4):
                        self.lines: List[str] = []
                        self.indent_level: int = 0
                        self.indent_size: int = indent_size
                        self.imports: Set[str] = set()
                    
                    def add_line(self, line: str = ""):
                        """Add a line with proper indentation"""
                        if line.strip():
                            indent = " " * (self.indent_level * self.indent_size)
                            self.lines.append(indent + line)
                        else:
                            self.lines.append("")
                    
                    def indent(self):
                        """Increase indentation level"""
                        self.indent_level += 1
                    
                    def dedent(self):
                        """Decrease indentation level"""
                        self.indent_level = max(0, self.indent_level - 1)
                    
                    def add_import(self, import_path: str):
                        """Add import to the set"""
                        self.imports.add(import_path)
                    
                    def build(self) -> str:
                        """Build final code string"""
                        return "\n".join(self.lines)
                    
                    def build_with_imports(self) -> str:
                        """Build code with imports at the top"""
                        import_lines = [f"import {imp}" for imp in sorted(self.imports)]
                        if import_lines:
                            import_lines.append("")  # Empty line after imports
                        
                        all_lines = import_lines + self.lines
                        return "\n".join(all_lines)
            </code>
        </file>
    </generator_implementation_examples>
    
    <template_system_examples>
        <file name="generator/templates/image_vector.j2">
            <template>
                {%- if imports %}
                {%- for import in imports %}
                import {{ import }}
                {%- endfor %}

                {% endif -%}
                {{ wrapper_start }}{{ build_code }}{{ wrapper_end }}
            </template>
        </file>
        
        <usage_examples>
            <example name="backing_property">
                <template>
                    wrapper_start: "val MyIcons.Home: ImageVector\n    get() {\n        if (_home != null) {\n            return _home!!\n        }\n        _home = "
                    wrapper_end: "\n        return _home!!\n    }\n\n@Suppress(\"ObjectPropertyName\")\nprivate var _home: ImageVector? = null"
                </template>
            </example>
            
            <example name="lazy_property">
                <template>
                    wrapper_start: "val MyIcons.Home: ImageVector by lazy(LazyThreadSafetyMode.NONE) {\n    "
                    wrapper_end: "\n}"
                </template>
            </example>
            
            <example name="simple_function">
                <template>
                    wrapper_start: "fun homeIcon(): ImageVector = "
                    wrapper_end: ""
                </template>
            </example>
        </usage_examples>
    </template_system_examples>
    
    <cli_implementation_example>
        <file name="cli.py">
            <code>
                import click
                from pathlib import Path
                from .core.processor import SvgProcessor
                from .core.config import Config
                
                @click.command()
                @click.argument('input_file', type=click.Path(exists=True, path_type=Path))
                @click.option('--output', '-o', type=click.Path(path_type=Path), 
                             help='Output file path (default: stdout)')
                @click.option('--template', '-t', type=str,
                             help='Template string or file path')
                @click.option('--wrapper-start', type=str, default='',
                             help='Template prefix (e.g., "val icon: ImageVector = ")')
                @click.option('--wrapper-end', type=str, default='',
                             help='Template suffix')
                @click.option('--config', '-c', type=click.Path(exists=True, path_type=Path),
                             help='Configuration file path')
                @click.option('--optimize/--no-optimize', default=True,
                             help='Enable/disable code optimizations')
                def convert(input_file, output, template, wrapper_start, wrapper_end, config, optimize):
                    """Convert SVG file to Compose ImageVector Kotlin code"""
                    
                    # Load configuration
                    cfg = Config()
                    if config:
                        cfg.load_from_file(config)
                    
                    # Override with command line options
                    if wrapper_start:
                        cfg.wrapper_start = wrapper_start
                    if wrapper_end:
                        cfg.wrapper_end = wrapper_end
                    cfg.optimize = optimize
                    
                    # Process SVG file
                    processor = SvgProcessor(cfg)
                    result = processor.convert_file(input_file)
                    
                    # Output result
                    if output:
                        output.write_text(result)
                        click.echo(f"Generated code written to {output}")
                    else:
                        click.echo(result)
                
                def main():
                    convert()
                
                if __name__ == '__main__':
                    main()
            </code>
        </file>
    </cli_implementation_example>
    
    <testing_strategy_examples>
        <test_categories>
            <category name="unit_tests">
                <test name="test_color_parsing">
                    <cases>
                        hex_colors, rgb_colors, rgba_colors, named_colors, invalid_colors
                    </cases>
                </test>
                <test name="test_path_parsing">
                    <cases>
                        simple_paths, complex_curves, relative_commands, arc_commands, malformed_paths
                    </cases>
                </test>
                <test name="test_ir_validation">
                    <cases>
                        valid_structures, invalid_parameters, missing_required_fields
                    </cases>
                </test>
            </category>
            
            <category name="integration_tests">
                <test name="test_svg_to_kotlin">
                    <input>simple_icon.svg</input>
                    <expected_output>working_kotlin_code.kt</expected_output>
                </test>
                <test name="test_gradient_conversion">
                    <input>gradient_icon.svg</input>
                    <verification>gradient_properties_preserved</verification>
                </test>
            </category>
        </test_categories>
    </testing_strategy_examples>
    
    <multicolor_template_system_examples>
        <file name="core/color_extractor.py">
            <code>
                from typing import Set, Union
                from ..ir.image_vector import IrImageVector
                from ..ir.vector_node import IrVectorPath, IrVectorGroup
                from ..ir.color import IrColor
                from ..ir.gradient import IrColorFill, IrLinearGradient, IrRadialGradient
                
                class ColorExtractor:
                    """Extract used colors from IrImageVector for multicolor template system"""
                    
                    def extract_colors(self, ir: IrImageVector) -> Set[str]:
                        """Extract all unique hex colors used in the SVG"""
                        colors = set()
                        for node in ir.nodes:
                            self._extract_from_node(node, colors)
                        return colors
                    
                    def _extract_from_node(self, node, colors: Set[str]):
                        """Recursively extract colors from vector node"""
                        if isinstance(node, IrVectorPath):
                            # Extract from fill
                            if node.fill:
                                self._extract_from_fill(node.fill, colors)
                            
                            # Extract from stroke
                            if node.stroke:
                                self._extract_from_fill(node.stroke, colors)
                        
                        elif isinstance(node, IrVectorGroup):
                            # Recursively process child nodes
                            for child in node.nodes:
                                self._extract_from_node(child, colors)
                    
                    def _extract_from_fill(self, fill, colors: Set[str]):
                        """Extract colors from fill/stroke objects"""
                        if isinstance(fill, IrColorFill):
                            colors.add(fill.color.to_hex())
                        elif isinstance(fill, (IrLinearGradient, IrRadialGradient)):
                            for color_stop in fill.color_stops:
                                colors.add(color_stop.color.to_hex())
                    
                    def is_multicolor(self, colors: Set[str]) -> bool:
                        """Check if SVG has multiple colors"""
                        return len(colors) > 1
            </code>
        </file>
        
        <file name="generator/multicolor_generator.py">
            <code>
                import re
                from typing import Dict, Any, Set
                from ..core.color_extractor import ColorExtractor
                
                class MulticolorGenerator:
                    """Enhanced generator with multicolor template support"""
                    
                    def __init__(self):
                        self.color_extractor = ColorExtractor()
                    
                    def generate_with_multicolor_support(self, ir: IrImageVector, template_context: Dict) -> Dict[str, Any]:
                        """Generate template context with multicolor support"""
                        
                        # Extract colors from IR
                        used_colors = self.color_extractor.extract_colors(ir)
                        is_multicolor = self.color_extractor.is_multicolor(used_colors)
                        
                        # Add multicolor variables to template context
                        template_context.update({
                            'used_colors': used_colors,
                            'is_multicolor': is_multicolor,
                            'build_code_with_color_params': None  # Will be set by template engine
                        })
                        
                        return template_context
                    
                    def substitute_color_parameters(self, code: str, color_mappings: Dict[str, Dict]) -> str:
                        """Replace Color(0xFFxxxxxx) with parameter references"""
                        
                        for color_hex, mapping in color_mappings.items():
                            semantic_name = mapping['semantic_name']
                            
                            # Convert hex to ARGB format for matching
                            if color_hex.startswith('#'):
                                hex_clean = color_hex[1:]
                                if len(hex_clean) == 6:
                                    hex_clean = 'FF' + hex_clean  # Add alpha
                                argb_hex = hex_clean.upper()
                                
                                # Replace patterns like Color(0xFF2196F3) with primaryColor
                                pattern = f'Color\\(0x{argb_hex}\\)'
                                code = re.sub(pattern, semantic_name, code)
                                
                                # Also replace SolidColor patterns
                                pattern = f'SolidColor\\(Color\\(0x{argb_hex}\\)\\)'
                                code = re.sub(pattern, f'SolidColor({semantic_name})', code)
                        
                        return code
            </code>
        </file>
        
        <file name="cli_multicolor_enhancement.py">
            <code>
                @click.option('--multicolor-template', '-mt', type=str,
                             help='Template for multicolor SVGs (when multiple colors detected)')
                def convert(input_file, output, template, multicolor_template, ...):
                    """Enhanced convert command with multicolor template support"""
                    
                    # Load configuration
                    cfg = Config()
                    if multicolor_template:
                        cfg.multicolor_template_path = Path(multicolor_template)
                    
                    # Process SVG file
                    processor = SvgProcessor(cfg)
                    
                    # Extract colors to determine template choice
                    ir = processor.parse_svg(input_file)
                    color_extractor = ColorExtractor()
                    used_colors = color_extractor.extract_colors(ir)
                    
                    # Select appropriate template
                    if len(used_colors) > 1 and cfg.multicolor_template_path:
                        selected_template = cfg.multicolor_template_path
                        use_multicolor = True
                    else:
                        selected_template = cfg.template_path
                        use_multicolor = False
                    
                    # Generate code with appropriate template
                    result = processor.generate_code(ir, selected_template, use_multicolor)
                    
                    # Output result
                    if output:
                        output.write_text(result)
                        click.echo(f"Generated {'multicolor' if use_multicolor else 'single-color'} code: {output}")
                    else:
                        click.echo(result)
            </code>
        </file>
        
        <usage_examples>
            <example name="multicolor_cli_usage">
                <command>
# Convert single SVG with multicolor template
uv run svg-to-compose convert icon.svg \
    --template default.j2 \
    --multicolor-template material_multicolor.j2

# Batch convert with automatic multicolor detection
uv run svg-to-compose batch icons/ \
    --template simple.j2 \
    --multicolor-template custom_multicolor.j2 \
    --output-dir generated/
                </command>
                <expected_output>
@Composable
fun MyIcon(
    primaryColor: Color = MaterialTheme.colorScheme.primary,
    accentColor: Color = Color(0xFFFF9800)
): ImageVector = ImageVector.Builder(
    name = "MyIcon",
    defaultWidth = 24.0.dp,
    defaultHeight = 24.0.dp,
    viewportWidth = 24.0f,
    viewportHeight = 24.0f
).apply {
    path(fill = SolidColor(primaryColor)) {
        moveTo(2.0f, 2.0f)
        lineTo(22.0f, 2.0f)
        // ...
    }
    path(fill = SolidColor(accentColor)) {
        moveTo(5.0f, 5.0f)
        // ...
    }
}.build()
                </expected_output>
            </example>
        </usage_examples>
        
        <user_template_examples>
            <note>No built-in multicolor templates - users create custom templates</note>
            <template name="material_theme_example.j2">
                <description>User-created Material Design style template</description>
                <template_code>
{# User-defined multicolor template with inline color mapping #}
{%- set color_mappings = {
    "#2196F3": {"semantic_name": "primaryColor", "default_value": "MaterialTheme.colorScheme.primary"},
    "#FF9800": {"semantic_name": "secondaryColor", "default_value": "MaterialTheme.colorScheme.secondary"},
    "#4CAF50": {"semantic_name": "tertiaryColor", "default_value": "MaterialTheme.colorScheme.tertiary"}
} -%}

{{- imports }}

@Composable
fun {{ name | pascal_case }}(
{%- for color_hex, mapping in color_mappings.items() if color_hex in used_colors %}
    {{ mapping.semantic_name }}: Color = {{ mapping.default_value }}{{ "," if not loop.last }}
{%- endfor %}
): ImageVector = {{ build_code_with_color_params }}
                </template_code>
            </template>
            <template name="custom_colors_example.j2">
                <description>User-created custom brand colors template</description>
                <template_code>
{# Custom brand colors multicolor template #}
{%- set color_mappings = {
    "#2196F3": {"semantic_name": "brandPrimary", "default_value": "Color(0xFF2196F3)"},
    "#FF9800": {"semantic_name": "brandAccent", "default_value": "Color(0xFFFF9800)"}
} -%}

{{- imports }}

@Composable
fun {{ name | pascal_case }}(
{%- for color_hex, mapping in color_mappings.items() if color_hex in used_colors %}
    {{ mapping.semantic_name }}: Color = {{ mapping.default_value }}{{ "," if not loop.last }}
{%- endfor %}
): ImageVector = {{ build_code_with_color_params }}
                </template_code>
            </template>
        </user_template_examples>
    </multicolor_template_system_examples>
    
    <validation_rules>
        <svg_validation>
            <rule>SVG must have valid XML structure</rule>
            <rule>Root element must be svg with width/height or viewBox</rule>
            <rule>Path data must follow SVG path specification</rule>
            <rule>Color values must be valid CSS colors</rule>
            <rule>Transform attributes must be valid transform functions</rule>
        </svg_validation>
        
        <ir_validation>
            <rule>ImageVector dimensions must be positive</rule>
            <rule>Color ARGB values must be valid 32-bit integers</rule>
            <rule>Path coordinates must be finite numbers</rule>
            <rule>Transform parameters must be within reasonable ranges</rule>
            <rule>Nested group structure must not exceed reasonable depth</rule>
        </ir_validation>
        
        <kotlin_validation>
            <rule>Generated code must be syntactically valid Kotlin</rule>
            <rule>All referenced classes must have proper imports</rule>
            <rule>Parameter values must be within Compose API constraints</rule>
            <rule>Generated ImageVector must be renderable without errors</rule>
        </kotlin_validation>
        
        <multicolor_validation>
            <rule>Color extraction must find all unique colors in SVG</rule>
            <rule>Color parameter substitution must be complete and accurate</rule>
            <rule>Generated @Composable function must have valid Kotlin syntax</rule>
            <rule>Template color mappings must cover all detected colors</rule>
            <rule>Backward compatibility: single-color SVGs work unchanged</rule>
        </multicolor_validation>
    </validation_rules>
</implementation_details>